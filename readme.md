Veredict: 
* I really like the material this course presents but I dislike the way it is presented. 
* All in all, recommended, but it would be so nice if it were better taught! 
* If I were to do it again, I would worry less about the exercises (I found them very easy) and more about doing a nice project at the end. Racket has good documentation.

Cons: 
* My main criticism is that there is nothing in the course particularly challenging or difficult, and yet, because no effort is made to explain the whys and wherefores of design decisions or provide useful analogies to Mathematics or other programming languages, the whole thing feels as arcane and dense as reading the Bible in Latin. Perhaps newer iterations of the course could do what so many other CS lecturers do: show code with bad design decisions or bad comments and then address the problems as a way to build understanding of why the system works the way it does. 
* I felt recursive list functions were particularly badly taught compared to the Andy Balaam lectures on Youtube, or Dan Grossman of the 'Programming Languages' UoW course. 
* In summary, the course often requires students make connections by themselves or rote learn the material. I feel if I had had less programming experience than I have I would have probably quit out of boredom.
* Too much copy & paste this recipe/template and too little explaining why the recipes are the way they are so we can remember them in 5 years or implement something similar when confronted with slightly different data structures.
* I felt I got no exposure to the Racket ecosystem, only a very limited dialect ('Beginning Student Language'). Spending some time on how to build GUIs inRacket would be very helpful.
* Exercises are easy, repetitive and tedious. I skipped most of them because I felt I was already doing the same exercise or a harder version of it in SICP or other courses. There is a lot to learn in CS to be wasting time on doing the same exercise over and over (first flying cows, then flying balloons, then flying bears, but now with list recursion! Yay! Seriously...).

Pros:
* Having said that, I still feel Systematic Program Design is worthy of study, and, seeing as there are no other MOOCs that cover this area, being patient and watching a sped up version of this course is worth it. I felt a lot more confident in my ability to plan and write maintainable, long term code after taking it.
* Parts 5 and 6 were good much better than the rest of the course. Less fluff, more interesting problems, methodology applied succintly and with less blabbing..
* The template approach seemed dumb at first but turned out to be a very good introduction to macros.
* I  felt the example/test + template approach to writing functions as well as 'wishlists' and working backwards are very effective techniques for problem solving. Before taking this course I would often write dummy versions of interfaces before adding functionality, but I never considered this as part of a broader workflow alongside tests. A large part of the course is refining specifications in a systematic way which was enlightening to see and clearly very useful.
